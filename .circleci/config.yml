# Python CircleCI 2.0 configuration file
# Check https://circleci.com/docs/2.0/language-python/ for more details
#
# References:
#     # how to setup multiple python versions
#     https://stackoverflow.com/questions/948354/default-behavior-of-git-push-without-a-branch-specified
#     https://github.com/adambrenecki/virtualfish/blob/aa3d6271bcb86ad27b6d24f96b5bd386d176f588/.circleci/config.yml
#
#     # Multiple files for a checksum
#     https://discuss.circleci.com/t/cant-checksum-multiple-files-with-slashes-in-the-file-path/20667/2
#     
#     # Auto Cancel Redundant Builds
#     https://circleci.com/docs/2.0/skip-build/#steps-to-enable-auto-cancel-for-pipelines-triggered-by-pushes-to-github-or-the-api
#     https://app.circleci.com/settings/project/github/pyutils/line_profiler/advanced?return-to=https%3A%2F%2Fapp.circleci.com%2Fpipelines%2Fgithub%2Fpyutils%2FPYPKG


# Abuse YAML notation to make a heredoc. This will be ignored by the CI.
__doc__: &__doc__
    - | 

        __doc__="""

        ============
        CIRCLECI INSTRUCTIONS
        ============

        This file was designed to be used as a template. You can adapt it to
        new projects with a few simple changes.  Namely perform the following
        search and replaces.

        ```bash
        cat .circleci/config.yml | \
            sed 's|pyutils|<YOUR-GITHUB-USERNAME>|g' | \
            sed 's|line_profiler|<YOUR-REPO>|g' | \
            sed 's|GPG_ID|<YOUR-GPG-ID>|g' | \
            sed 's|PYUTILS_CI_GITHUB_SECRET|<YOUR_CI_SECRET>|g' | \
        tee /tmp/repl && colordiff .circleci/config.yml /tmp/repl
        ```

        To use this script you need the following configurations on your
        CircleCI account.

        NOTES
        -----

        * This script will require matainence for new releases of Python

        * Make sure you add Runners to your project 
        https://gitlab.kitware.com/computer-vision/line_profiler/-/settings/ci_cd 
        in Runners-> Shared Runners
        and Runners-> Available specific runners
        

        CIRCLECI SECRETS  # NOQA
        --------------

        https://app.circleci.com/settings/project/github/pyutils/line_profiler/environment-variables

        Almost all of the stages in this pipeline can be performed on a local
        machine (making it much easier to debug) as well as the circleci-ci
        machine. However, there are a handeful of required environment
        variables which will contain sensitive information. These variables are

        * PYUTILS_TWINE_USERNAME - this is your pypi username
            twine info is only needed if you want to automatically publish to pypi

        * PYUTILS_TWINE_PASSWORD - this is your pypi password 

        * PYUTILS_CI_GITHUB_SECRET - We will use this as a secret key to encrypt/decrypt gpg secrets 
            This is only needed if you want to automatically sign published
            wheels with a gpg key.

        * GITHUB_PUSH_TOKEN - 
            This is only needed if you want to automatically git-tag release branches.

            To make a API token go to:
                https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/creating-a-personal-access-token

                # For an organizatino, make a deploy key, not really 100% sure to do this correctly
                # https://stackoverflow.com/questions/26372417/github-oauth2-token-how-to-restrict-access-to-read-a-single-private-repo
                # https://github.com/pyutils/line_profiler/settings/keys

        Register these secret variables in your projects secret environment variables
            https://app.circleci.com/settings/project/github/pyutils/line_profiler/environment-variables

        WARNING: Ensure that your CircleCI project settings do not allow Forks
            to view environment variables.

        TODO: Can you protect branches on CircleCI, is that the default?

        WARNING: If an untrusted actor gains the ability to write to a
        protected branch, then they will be able to exfiltrate your secrets.

        WARNING: These variables contain secret information. Ensure that these
        the protected and masked settings are enabled when you create them.


        ENCRYPTING GPG SECRETS
        ----------------------

        The following script demonstrates how to securely encrypt a secret GPG key. It is assumed that you have 
        a file secret_loader.sh that looks like this

        ```bash
            source secretfile
        ```

        and then a secretfile that looks like this

        ```bash
            #!/bin/bash
            echo /some/secret/file 

            export PYUTILS_TWINE_USERNAME=<pypi-username>
            export PYUTILS_TWINE_PASSWORD=<pypi-password>
            export PYUTILS_CI_GITHUB_SECRET="<a-very-long-secret-string>"
            export GITHUB_PUSH_TOKEN='git-push-token:<token-password>'
        ```

        You should also make a secret_unloader.sh that points to a script that
        unloads these secret variables from the environment.

        Given this file-structure setup, you can then run the following
        commands verbatim. Alternatively just populate the environment
        variables and run line-by-line without creating the secret
        loader/unloader scripts.
        
        ```bash
        # THIS IS NOT EXECUTE ON THE CI, THIS IS FOR DEVELOPER REFERENCE
        # ON HOW THE ENCRYPTED GPG KEYS ARE SETUP.
        
        # Load or generate secrets
        source $(secret_loader.sh)
        echo $PYUTILS_CI_GITHUB_SECRET
        echo $PYUTILS_TWINE_USERNAME

        # ADD RELEVANT VARIABLES TO CIRCLECI SECRET VARIABLES
        # https://app.circleci.com/settings/project/github/pyutils/line_profiler/environment-variables
        # See previous CIRCLE_CI section for more details

        # HOW TO ENCRYPT YOUR SECRET GPG KEY
        IDENTIFIER="PyUtils"
        GPG_KEYID=$(gpg --list-keys --keyid-format LONG "$IDENTIFIER" | head -n 2 | tail -n 1 | awk '{print $1}' | tail -c 9)
        echo "GPG_KEYID = $GPG_KEYID"

        # Export plaintext gpg public keys, private keys, and trust info
        mkdir -p dev
        gpg --armor --export-secret-keys $GPG_KEYID > dev/cci_secret_gpg_key.pgp
        gpg --armor --export $GPG_KEYID > dev/cci_public_gpg_key.pgp
        gpg --export-ownertrust > dev/cci_gpg_owner_trust

        # Encrypt gpg keys and trust with CI secret
        GLKWS=$PYUTILS_CI_GITHUB_SECRET openssl enc -aes-256-cbc -pbkdf2 -md SHA512 -pass env:GLKWS -e -a -in dev/cci_public_gpg_key.pgp > dev/cci_public_gpg_key.pgp.enc
        GLKWS=$PYUTILS_CI_GITHUB_SECRET openssl enc -aes-256-cbc -pbkdf2 -md SHA512 -pass env:GLKWS -e -a -in dev/cci_secret_gpg_key.pgp > dev/cci_secret_gpg_key.pgp.enc
        GLKWS=$PYUTILS_CI_GITHUB_SECRET openssl enc -aes-256-cbc -pbkdf2 -md SHA512 -pass env:GLKWS -e -a -in dev/cci_gpg_owner_trust > dev/cci_gpg_owner_trust.enc
        echo $GPG_KEYID > dev/public_gpg_key

        # Test decrpyt
        cat dev/public_gpg_key
        GLKWS=$PYUTILS_CI_GITHUB_SECRET openssl enc -aes-256-cbc -pbkdf2 -md SHA512 -pass env:GLKWS -d -a -in dev/cci_public_gpg_key.pgp.enc 
        GLKWS=$PYUTILS_CI_GITHUB_SECRET openssl enc -aes-256-cbc -pbkdf2 -md SHA512 -pass env:GLKWS -d -a -in dev/cci_gpg_owner_trust.enc 
        GLKWS=$PYUTILS_CI_GITHUB_SECRET openssl enc -aes-256-cbc -pbkdf2 -md SHA512 -pass env:GLKWS -d -a -in dev/cci_secret_gpg_key.pgp.enc 

        source $(secret_unloader.sh)

        # Look at what we did, clean up, and add it to git
        ls dev/*.enc
        rm dev/cci_gpg_owner_trust dev/*.pgp
        git status
        git add dev/*.enc
        git add dev/public_gpg_key
        ```


        TEST GITHUB_PUSH_TOKEN 
        -------------------

        The following script tests if your GITHUB_PUSH_TOKEN environment variable is correctly setup.

        ```bash
        docker run -it ubuntu
        apt update -y && apt install git -y
        git clone https://github.com/pyutils/line_profiler.git
        cd line_profiler
        # do sed twice to handle the case of https clone with and without a read token
        git config user.email "ci@circleci.com"
        git config user.name "CircleCI-User"
        URL_HOST=$(git remote get-url origin | sed -e 's|https\?://.*@||g' | sed -e 's|https\?://||g')
        echo "URL_HOST = $URL_HOST"
        git tag "test-tag4"
        git push --tags "https://${GITHUB_PUSH_TOKEN}@${URL_HOST}"

        # Cleanup after you verify the tags shows up on the remote
        git push --delete origin test-tag4
        git tag --delete test-tag4
        ```


        """ # "  # hack for vim yml syntax highlighter

version: 2
workflows:
  version: 2
  test:
    jobs:
      - test_full/cp39-cp39-manylinux2010
      - test_full/cp38-cp38-manylinux2010
      - test_full/cp37-cp37m-manylinux2010
      - test_full/cp36-cp36m-manylinux2010
      - test_full/cp35-cp35m-manylinux2010

      - gpgsign/cp39-cp39-manylinux2010:
          requires:
              - test_full/cp39-cp39-manylinux2010

      - gpgsign/cp38-cp38-manylinux2010:
          requires:
              - test_full/cp38-cp38-manylinux2010

      - gpgsign/cp37-cp37m-manylinux2010:
          requires:
              - test_full/cp37-cp37m-manylinux2010

      - gpgsign/cp36-cp36m-manylinux2010:
          requires:
              - test_full/cp36-cp36m-manylinux2010

      - gpgsign/cp35-cp35m-manylinux2010:
          requires:
              - test_full/cp35-cp35m-manylinux2010

      #- deploy/cp38-cp38-manylinux2010:
      #    filters:
      #      branches:
      #        only: 
      #           - release


jobs:

  ###########
  # TEMPLATES
  ###########

  .common_template: &common_template
    environment:
      # Setting the python executable environ allows template reuse for pypy
      - PYTHON_EXE: python
    docker:
      - image: circleci/python
    steps:
      - checkout


  .test_full_template: &test_full_template  
    <<: 
        - *common_template
    resource_class: small
    steps:
      - checkout
      - run:
          name: prepare_env
          command: |
            $PYTHON_EXE -m venv venv
            # $PYTHON_EXE -m pip install --upgrade pip
            . venv/bin/activate
            # pip install --upgrade pip
      - run:
          name: build_wheel
          command: |
            . venv/bin/activate
            MB_PYTHON_TAG=$(python -c "import setup; print(setup.MB_PYTHON_TAG)") 
            VERSION=$(python -c "import setup; print(setup.VERSION)") 
            _INSIDE_DOCKER=YES REPO_ROOT="." MB_PYTHON_TAG=$MB_PYTHON_TAG ./run_manylinux_build.sh
      - persist_to_workspace:
          root: .
          paths:
              - dist
      - run:
          name: install_wheel
          command: |
            . venv/bin/activate
            # pip install --upgrade pip
            MB_PYTHON_TAG=$(python -c "import setup; print(setup.MB_PYTHON_TAG)") 
            VERSION=$(python -c "import setup; print(setup.VERSION)") 
            BDIST_WHEEL_PATH=$(ls dist/*-$VERSION-$MB_PYTHON_TAG*.whl)
            pip install ${BDIST_WHEEL_PATH}[all]
      - run:
          name: run_tests
          command: |
            . venv/bin/activate
            python run_tests.py
      #- store_artifacts:
      #    path: .coverage
      #    destination: .coverage


  .gpgsign_template: &gpgsign_template  
    <<: 
        - *common_template
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          name: sign_and_deploy
          command: |
            #$PYTHON_EXE -m venv venv || virtualenv -v venv  # first command is python3 || second is python2
            #. venv/bin/activate
            ls -al
            ls -al dist
            export GPG_EXECUTABLE=gpg
            export GPG_KEYID=$(cat dev/public_gpg_key)
            echo "GPG_KEYID = $GPG_KEYID"
            echo "-- QUERY GPG VERSION..."
            $GPG_EXECUTABLE --version
            echo "-- QUERY OPENSSL VERSION..."
            openssl version
            echo "-- QUERY GPG KEYS (done twice as a workaround)"
            $GPG_EXECUTABLE --list-keys || $GPG_EXECUTABLE --list-keys
            echo "-- QUERY GPG KEYS (done twice as a workaround)"
            $GPG_EXECUTABLE --list-keys || $GPG_EXECUTABLE --list-keys
            echo "-- Decrypt and import GPG Keys / trust"
            # note PYUTILS_CI_GITHUB_SECRET is a protected variables only available on master and release branch
            echo "PYUTILS_CI_GITHUB_SECRET = $PYUTILS_CI_GITHUB_SECRET"
            GLKWS=$PYUTILS_CI_GITHUB_SECRET openssl enc -aes-256-cbc -pbkdf2 -md SHA512 -pass env:GLKWS -d -a -in dev/cci_public_gpg_key.pgp.enc | $GPG_EXECUTABLE --import 
            GLKWS=$PYUTILS_CI_GITHUB_SECRET openssl enc -aes-256-cbc -pbkdf2 -md SHA512 -pass env:GLKWS -d -a -in dev/cci_gpg_owner_trust.enc | $GPG_EXECUTABLE --import-ownertrust
            GLKWS=$PYUTILS_CI_GITHUB_SECRET openssl enc -aes-256-cbc -pbkdf2 -md SHA512 -pass env:GLKWS -d -a -in dev/cci_secret_gpg_key.pgp.enc | $GPG_EXECUTABLE --import 
            $GPG_EXECUTABLE --list-keys  || echo "first one fails for some reason"
            $GPG_EXECUTABLE --list-keys  
            # The publish script only builds wheels and does gpg signing if DO_UPLOAD is no
            pip install requests[security] twine wheel
            if [[ "${CIRCLE_BRANCH}" != "release" ]]; then
                # ----
                echo "Execute the publish script in dry mode"
                MB_PYTHON_TAG=$MB_PYTHON_TAG DO_GPG=True GPG_KEYID=$GPG_KEYID GPG_EXECUTABLE=$GPG_EXECUTABLE DO_UPLOAD=False DO_TAG=False ./publish.sh 
            else
                # ----
                # Install twine
                pip install six pyopenssl ndg-httpsclient pyasn1 -U 
                # Execute the publish script for real this time
                MB_PYTHON_TAG=$MB_PYTHON_TAG DO_GPG=True GPG_KEYID=$GPG_KEYID TWINE_PASSWORD=$PYUTILS_TWINE_PASSWORD TWINE_USERNAME=$PYUTILS_TWINE_USERNAME GPG_EXECUTABLE=$GPG_EXECUTABLE DO_UPLOAD=True DO_TAG=False ./publish.sh 
                # Have the server git-tag the release and push the tags
                VERSION=$($PYTHON_EXE -c "import setup; print(setup.VERSION)")
                # do sed twice to handle the case of https clone with and without a read token
                URL_HOST=$(git remote get-url origin | sed -e 's|https\?://.*@||g' | sed -e 's|https\?://||g')
                echo "URL_HOST = $URL_HOST"
                # TODO: need to fix this on CI
                # A git config user name and email is required. Set if needed.
                # Need to figure out how to use deploy keys with this
                #if [[ "$(git config user.email)" == "" ]]; then
                #    git config user.email "ci@circleci.com"
                #    git config user.name "CircleCI"
                #fi
                #if [ $(git tag -l "$VERSION") ]; then
                #    echo "Tag already exists"
                #else
                #    git tag $VERSION -m "tarball tag $VERSION"
                #    git push --tags "https://${GITHUB_PUSH_TOKEN}@${URL_HOST}"
                #fi
            fi

      - store_artifacts:
          path: dist
          destination: dist

      - store_artifacts:
          path: wheelhouse
          destination: wheelhouse


  ###################################
  ### INHERIT FROM BASE TEMPLATES ###
  ###################################

  # Define tests fo the other python verisons using the "test3.6" template
  # and indicating what needs to be modified.
  #
  # All we need to do is change the base docker image so python is the
  # version we want we can reuse everything else from the template
  
  test_full/cp39-cp39-manylinux2010:
    <<: *test_full_template
    environment:
      - PYTHON_EXE: /opt/python/cp39-cp39/bin/python
      - MB_PYTHON_TAG=cp39-cp39
    docker:
      - image: quay.io/pypa/manylinux2010_x86_64:latest
    working_directory: ~/repo-full-cp39
  
  test_full/cp38-cp38-manylinux2010:
    <<: *test_full_template
    environment:
      - PYTHON_EXE: /opt/python/cp38-cp38/bin/python
      - MB_PYTHON_TAG=cp38-cp38
    docker:
      - image: quay.io/pypa/manylinux2010_x86_64:latest
    working_directory: ~/repo-full-cp38
  
  test_full/cp37-cp37m-manylinux2010:
    <<: *test_full_template
    environment:
      - PYTHON_EXE: /opt/python/cp37-cp37m/bin/python
      - MB_PYTHON_TAG=cp37-cp37m
    docker:
      - image: quay.io/pypa/manylinux2010_x86_64:latest
    working_directory: ~/repo-full-cp37

  test_full/cp36-cp36m-manylinux2010:
    <<: *test_full_template
    environment:
      - PYTHON_EXE: /opt/python/cp36-cp36m/bin/python
      - MB_PYTHON_TAG=cp36-cp36m
    docker:
      - image: quay.io/pypa/manylinux2010_x86_64:latest
    working_directory: ~/repo-full-cp36

  test_full/cp35-cp35m-manylinux2010:
    <<: *test_full_template
    environment:
      - PYTHON_EXE: /opt/python/cp35-cp35m/bin/python
      - MB_PYTHON_TAG=cp35-cp35m
    docker:
      - image: quay.io/pypa/manylinux2010_x86_64:latest
    working_directory: ~/repo-full-cp35
 
  # -- gpgsign + deploy
  # We have to use a different image to do GPG signing
  
  gpgsign/cp39-cp39-manylinux2010:
    <<: *gpgsign_template
    environment:
      - MB_PYTHON_TAG=cp39-cp39
    docker:
      - image: circleci/python:3.9
    working_directory: ~/gpgsign/cp39-cp39-manylinux2010
  
  gpgsign/cp38-cp38-manylinux2010:
    <<: *gpgsign_template
    environment:
      - MB_PYTHON_TAG=cp38-cp38
    docker:
      - image: circleci/python:3.8
    working_directory: ~/gpgsign/cp38-cp38-manylinux2010
  
  gpgsign/cp37-cp37m-manylinux2010:
    <<: *gpgsign_template
    environment:
      - MB_PYTHON_TAG=cp37-cp37m
    docker:
      - image: circleci/python:3.7
    working_directory: ~/gpgsign/cp37-cp37m-manylinux2010
  
  gpgsign/cp36-cp36m-manylinux2010:
    <<: *gpgsign_template
    environment:
      - MB_PYTHON_TAG=cp36-cp36m
    docker:
      - image: circleci/python:3.6
    working_directory: ~/gpgsign/cp36-cp36m-manylinux2010

  gpgsign/cp35-cp35m-manylinux2010:
    <<: *gpgsign_template
    environment:
      - MB_PYTHON_TAG=cp35-cp35m
    docker:
      - image: circleci/python:3.5
    working_directory: ~/gpgsign/cp35-cp35m-manylinux2010


__scratch_work__:
    docker:
      - image: pypy:3
    working_directory: ~/dev-only-not-a-real-job
    steps:
      - | 
        __doc__=" 
        # Run circleci scripts on a local machine
        mkdir -p $HOME/Downloads
        curl -fLSs https://raw.githubusercontent.com/CircleCI-Public/circleci-cli/master/install.sh | DESTDIR=$HOME/Downloads bash

        $HOME/.local/bin/circleci update
        $HOME/.local/bin/circleci switch

        $HOME/.local/bin/circleci config validate
        $HOME/.local/bin/circleci local execute --job test_full/cp39-cp39-manylinux2010
        $HOME/.local/bin/circleci local execute --config .circleci/config.yml --job test_full/cp38-cp38-manylinux2010
        $HOME/.local/bin/circleci local execute --config .circleci/config.yml 

        $HOME/.local/bin/circleci local execute --job test_full/cp38-cp38-manylinux2010

        load_secrets
        $HOME/.local/bin/circleci local execute --config .circleci/config.yml \
            -e GITHUB_PUSH_TOKEN=$GITHUB_PUSH_TOKEN \
            -e PYUTILS_CI_GITHUB_SECRET=$PYUTILS_CI_GITHUB_SECRET \
            --job gpgsign/cp38-cp38-manylinux2010
        "
